import _typeof from "@babel/runtime/helpers/typeof";
import _createClass from "@babel/runtime/helpers/createClass";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable max-classes-per-file */
import Session from "./Session";
import Model from "./Model";
import { createDatabase as defaultCreateDatabase } from "./db";
import { attr } from "./fields";
import Field from "./fields/Field";
import ForeignKey from "./fields/ForeignKey";
import ManyToMany from "./fields/ManyToMany";
import { createModelSelectorSpec } from "./selectors";
import { m2mName, attachQuerySetMethods, m2mToFieldName, m2mFromFieldName, warnDeprecated } from "./utils";
var ORM_DEFAULTS = {
  createDatabase: defaultCreateDatabase
};
var RESERVED_TABLE_OPTIONS = ["indexes", "meta"];

var isReservedTableOption = function isReservedTableOption(word) {
  return RESERVED_TABLE_OPTIONS.includes(word);
};
/**
 * ORM - the Object Relational Mapper.
 *
 * Use instances of this class to:
 *
 * - Register your {@link Model} classes using {@link ORM#register}
 * - Get the empty state for the underlying database with {@link ORM#getEmptyState}
 * - Start an immutable database session with {@link ORM#session}
 * - Start a mutating database session with {@link ORM#mutableSession}
 *
 * Internally, this class handles generating a schema specification from models
 * to the database.
 */


var ORM = /*#__PURE__*/function () {
  /**
   * Creates a new ORM instance.
   *
   * @param {Object} [opts]
   * @param {Function} [opts.stateSelector] - function that given a Redux state tree
   *                                          will return the ORM state's subtree,
   *                                          e.g. `state => state.orm`
   *                                          (necessary if you want to use selectors)
   * @param {Function} [opts.createDatabase] - function that creates a database
   */
  function ORM(opts) {
    var _ORM_DEFAULTS = _objectSpread(_objectSpread({}, ORM_DEFAULTS), opts || {}),
        createDatabase = _ORM_DEFAULTS.createDatabase;

    this.createDatabase = createDatabase;
    this.registry = [];
    this.implicitThroughModels = [];
    this.installedFields = {};
    this.stateSelector = opts ? opts.stateSelector : null;
  }
  /**
   * Registers a {@link Model} class to the ORM.
   *
   * If the model has declared any ManyToMany fields, their
   * through models will be generated and registered with
   * this call, unless a custom through model has been specified.
   *
   * @param  {...Model} models - a {@link Model} class to register
   * @return {undefined}
   */


  var _proto = ORM.prototype;

  _proto.register = function register() {
    var _this = this;

    for (var _len = arguments.length, models = new Array(_len), _key = 0; _key < _len; _key++) {
      models[_key] = arguments[_key];
    }

    models.forEach(function (model) {
      if (model.modelName === undefined) {
        throw new Error("A model was passed that doesn't have a modelName set");
      }

      model.invalidateClassCache();

      _this.registerManyToManyModelsFor(model);

      _this.registry.push(model);

      Object.defineProperty(_this, model.modelName, {
        get: function get() {
          // make sure virtualFields are set up
          _this._setupModelPrototypes(_this.registry);

          return createModelSelectorSpec({
            model: model,
            orm: _this
          });
        }
      });
    });
  };

  _proto.registerManyToManyModelsFor = function registerManyToManyModelsFor(model) {
    var _this2 = this;

    var fields = model.fields;
    var thisModelName = model.modelName;
    Object.entries(fields).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          fieldName = _ref2[0],
          fieldInstance = _ref2[1];

      if (!(fieldInstance instanceof ManyToMany)) {
        return;
      }

      var toModelName;

      if (fieldInstance.toModelName === "this") {
        toModelName = thisModelName;
      } else {
        toModelName = fieldInstance.toModelName; // eslint-disable-line prefer-destructuring
      }

      var selfReferencing = thisModelName === toModelName;
      var fromFieldName = m2mFromFieldName(thisModelName);
      var toFieldName = m2mToFieldName(toModelName);

      if (fieldInstance.through) {
        if (selfReferencing && !fieldInstance.throughFields) {
          throw new Error("Self-referencing many-to-many relationship at " + "\"".concat(thisModelName, ".").concat(fieldName, "\" using custom ") + "model \"".concat(fieldInstance.through, "\" has no ") + "throughFields key. Cannot determine which " + "fields reference the instances partaking " + "in the relationship.");
        }
      } else {
        var _Through$fields;

        var Through = /*#__PURE__*/function (_Model) {
          _inheritsLoose(ThroughModel, _Model);

          function ThroughModel() {
            return _Model.apply(this, arguments) || this;
          }

          return ThroughModel;
        }(Model);

        Through.modelName = m2mName(thisModelName, fieldName);

        var PlainForeignKey = /*#__PURE__*/function (_ForeignKey) {
          _inheritsLoose(PlainForeignKey, _ForeignKey);

          function PlainForeignKey() {
            return _ForeignKey.apply(this, arguments) || this;
          }

          _createClass(PlainForeignKey, [{
            key: "installsBackwardsVirtualField",
            get: function get() {
              return false;
            }
          }, {
            key: "installsBackwardsDescriptor",
            get: function get() {
              return false;
            }
          }]);

          return PlainForeignKey;
        }(ForeignKey);

        var ForeignKeyClass = selfReferencing ? PlainForeignKey : ForeignKey;
        Through.fields = (_Through$fields = {
          id: attr()
        }, _defineProperty(_Through$fields, fromFieldName, new ForeignKeyClass(thisModelName)), _defineProperty(_Through$fields, toFieldName, new ForeignKeyClass(toModelName)), _Through$fields);
        Through.invalidateClassCache();

        _this2.implicitThroughModels.push(Through);
      }
    });
  }
  /**
   * Gets a {@link Model} class by its name from the registry.
   * @param  {string} modelName - the name of the {@link Model} class to get
   * @throws If {@link Model} class is not found.
   * @return {Model} the {@link Model} class, if found
   */
  ;

  _proto.get = function get(modelName) {
    var allModels = this.registry.concat(this.implicitThroughModels);
    var found = Object.values(allModels).find(function (model) {
      return model.modelName === modelName;
    });

    if (typeof found === "undefined") {
      throw new Error("Did not find model ".concat(modelName, " from registry."));
    }

    return found;
  };

  _proto.getModelClasses = function getModelClasses() {
    this._setupModelPrototypes(this.registry);

    this._setupModelPrototypes(this.implicitThroughModels);

    return this.registry.concat(this.implicitThroughModels);
  };

  _proto.generateSchemaSpec = function generateSchemaSpec() {
    var models = this.getModelClasses();
    var tables = models.reduce(function (spec, modelClass) {
      var tableName = modelClass.modelName;
      var tableSpec = modelClass.tableOptions();
      Object.keys(tableSpec).filter(isReservedTableOption).forEach(function (key) {
        throw new Error("Reserved keyword `".concat(key, "` used in ").concat(tableName, ".options."));
      });
      spec[tableName] = _objectSpread({
        fields: _objectSpread({}, modelClass.fields)
      }, tableSpec);
      return spec;
    }, {});
    return {
      tables: tables
    };
  };

  _proto.getDatabase = function getDatabase() {
    if (!this.db) {
      this.db = this.createDatabase(this.generateSchemaSpec());
    }

    return this.db;
  }
  /**
   * Returns the empty database state.
   * @return {Object} the empty state
   */
  ;

  _proto.getEmptyState = function getEmptyState() {
    return this.getDatabase().getEmptyState();
  }
  /**
   * Begins an immutable database session.
   *
   * @param  {Object} state  - the state the database manages
   * @return {Session} a new {@link Session} instance
   */
  ;

  _proto.session = function session(state) {
    return new Session(this, this.getDatabase(), state);
  }
  /**
   * Begins a mutable database session.
   *
   * @param  {Object} state  - the state the database manages
   * @return {Session} a new {@link Session} instance
   */
  ;

  _proto.mutableSession = function mutableSession(state) {
    return new Session(this, this.getDatabase(), state, true);
  }
  /**
   * @private
   */
  ;

  _proto._setupModelPrototypes = function _setupModelPrototypes(models) {
    var _this3 = this;

    models.filter(function (model) {
      return !model.isSetUp;
    }).forEach(function (model) {
      var fields = model.fields,
          modelName = model.modelName,
          querySetClass = model.querySetClass;
      Object.entries(fields).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            fieldName = _ref4[0],
            field = _ref4[1];

        if (!(field instanceof Field)) {
          throw new Error("".concat(modelName, ".").concat(fieldName, " is of type \"").concat(_typeof(field), "\" ") + "but must be an instance of Field. Please use the " + "`attr`, `fk`, `oneToOne` and `many` " + "functions to define fields.");
        }

        if (!_this3._isFieldInstalled(modelName, fieldName)) {
          _this3._installField(field, fieldName, model);

          _this3._setFieldInstalled(modelName, fieldName);
        }
      });
      attachQuerySetMethods(model, querySetClass);
      model.isSetUp = true;
    });
  }
  /**
   * @private
   */
  ;

  _proto._isFieldInstalled = function _isFieldInstalled(modelName, fieldName) {
    return this.installedFields.hasOwnProperty(modelName) ? !!this.installedFields[modelName][fieldName] : false;
  }
  /**
   * @private
   */
  ;

  _proto._setFieldInstalled = function _setFieldInstalled(modelName, fieldName) {
    if (!this.installedFields.hasOwnProperty(modelName)) {
      this.installedFields[modelName] = {};
    }

    this.installedFields[modelName][fieldName] = true;
  }
  /**
   * Installs a field on a model and its related models if necessary.
   * @private
   */
  ;

  _proto._installField = function _installField(field, fieldName, model) {
    var FieldInstaller = field.installerClass;
    new FieldInstaller({
      field: field,
      fieldName: fieldName,
      model: model,
      orm: this
    }).run();
  } // DEPRECATED AND REMOVED METHODS

  /**
   * @deprecated Use {@link ORM#mutableSession} instead.
   */
  ;

  _proto.withMutations = function withMutations(state) {
    warnDeprecated("`ORM.prototype.withMutations` has been deprecated. " + "Use `ORM.prototype.mutableSession` instead.");
    return this.mutableSession(state);
  }
  /**
   * @deprecated Use {@link ORM#session} instead.
   */
  ;

  _proto.from = function from(state) {
    warnDeprecated("`ORM.prototype.from` has been deprecated. " + "Use `ORM.prototype.session` instead.");
    return this.session(state);
  }
  /**
   * @deprecated Use {@link ORM#getEmptyState} instead.
   */
  ;

  _proto.getDefaultState = function getDefaultState() {
    warnDeprecated("`ORM.prototype.getDefaultState` has been deprecated. Use " + "`ORM.prototype.getEmptyState` instead.");
    return this.getEmptyState();
  }
  /**
   * @deprecated Define a Model class instead.
   */
  ;

  _proto.define = function define() {
    throw new Error("`ORM.prototype.define` has been removed. Please define a Model class.");
  };

  return ORM;
}();

export function DeprecatedSchema() {
  throw new Error("Schema has been renamed to ORM. Please import ORM instead of Schema " + "from Redux-ORM.");
}
export { ORM };
export default ORM;