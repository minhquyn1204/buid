import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _typeof from "@babel/runtime/helpers/typeof";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import ops from "immutable-ops";
import filter from "lodash/filter";
import orderBy from "lodash/orderBy";
import reject from "lodash/reject";
import sortBy from "lodash/sortBy";
import { EXCLUDE, FILTER, ORDER_BY } from "../constants";
import { clauseFiltersByAttribute, clauseReducesResultSetSize } from "../utils";
var DEFAULT_TABLE_OPTIONS = {
  idAttribute: "id",
  arrName: "items",
  mapName: "itemsById",
  fields: {}
};
/**
 * @private
 * @param {*} _currMax - the current max id
 * @param {*} userPassedId - the new id passed to the create action
 *
 * Both may be undefined. The current max id in the case that this is the first Model
 * being created, and the new id if the id was not explicitly passed to the
 * database.
 *
 * @return {Array} the new max id and the id to use to create the new row
 *
 * If the id's are strings, the id must be passed explicitly every time.
 * In this case, the current max id will remain `NaN` due to `Math.max`, but that's fine.
 */

function idSequencer(_currMax, userPassedId) {
  var currMax = _currMax;
  var newMax;
  var newId;

  if (currMax === undefined) {
    currMax = -1;
  }

  if (userPassedId === undefined) {
    newMax = currMax + 1;
    newId = newMax;
  } else {
    newMax = Math.max(currMax + 1, userPassedId);
    newId = userPassedId;
  }

  return [newMax, // new max id
  newId // id to use for row creation
  ];
}
/**
 * Adapt order directions array to @{lodash.orderBy} API.
 *
 * @private
 *
 * @param {Array<Boolean|'asc'|'desc'>} orders? - an array of optional order query directions as provided to {@Link {QuerySet.orderBy}}
 * @return {Array<'asc'|'desc'>|undefined} A normalized ordering array or undefined if none was provided.
 */


function normalizeOrders(orders) {
  if (orders === undefined) {
    return undefined;
  }

  var convert = function convert(order) {
    if (["desc", false].includes(order)) {
      return "desc";
    }

    return "asc";
  };

  return Array.isArray(orders) ? orders.map(convert) : convert(orders);
}
/**
 * Handles the underlying data structure for a {@link Model} class.
 * @private
 */


export var Table = /*#__PURE__*/function () {
  /**
   * Creates a new {@link Table} instance.
   * @param  {Object} userOpts - options to use.
   * @param  {string} [userOpts.idAttribute=id] - the id attribute of the entity.
   * @param  {string} [userOpts.arrName=items] - the state attribute where an array of
   *                                             entity id's are stored
   * @param  {string} [userOpts.mapName=itemsById] - the state attribute where the entity objects
   *                                                 are stored in a id to entity object
   *                                                 map.
   * @param  {string} [userOpts.fields={}] - mapping of field key to {@link Field} object
   */
  function Table(userOpts) {
    Object.assign(this, DEFAULT_TABLE_OPTIONS, userOpts);
  }
  /**
   * Returns a reference to the object at index `id`
   * in state `branch`.
   *
   * @param  {Object} branch - the state
   * @param  {Number} id - the id of the object to get
   * @return {Object|undefined} A reference to the raw object in the state or
   *                            `undefined` if not found.
   */


  var _proto = Table.prototype;

  _proto.accessId = function accessId(branch, id) {
    return branch[this.mapName][id];
  };

  _proto.accessIds = function accessIds(branch, ids) {
    var map = branch[this.mapName];
    return ids.map(function (id) {
      return map[id];
    });
  };

  _proto.idExists = function idExists(branch, id) {
    return branch[this.mapName].hasOwnProperty(id);
  };

  _proto.accessIdList = function accessIdList(branch) {
    return branch[this.arrName];
  };

  _proto.accessList = function accessList(branch) {
    return this.accessIds(branch, this.accessIdList(branch));
  };

  _proto.getMaxId = function getMaxId(branch) {
    return this.getMeta(branch, "maxId");
  };

  _proto.setMaxId = function setMaxId(tx, branch, newMaxId) {
    return this.setMeta(tx, branch, "maxId", newMaxId);
  };

  _proto.nextId = function nextId(id) {
    return id + 1;
  }
  /**
   * Returns the default state for the data structure.
   * @return {Object} The default state for this {@link ORM} instance's data structure
   */
  ;

  _proto.getEmptyState = function getEmptyState() {
    var _pkIndex,
        _this = this;

    var pkIndex = (_pkIndex = {}, _defineProperty(_pkIndex, this.arrName, []), _defineProperty(_pkIndex, this.mapName, {}), _pkIndex);
    var attrIndexes = Object.keys(this.fields).filter(function (attr) {
      return attr !== _this.idAttribute;
    }).filter(function (attr) {
      return _this.fields[attr].index;
    }).reduce(function (indexes, attr) {
      return _objectSpread(_objectSpread({}, indexes), {}, _defineProperty({}, attr, {}));
    }, {});
    return _objectSpread(_objectSpread({}, pkIndex), {}, {
      indexes: attrIndexes,
      meta: {}
    });
  };

  _proto.setMeta = function setMeta(tx, branch, key, value) {
    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;

    if (withMutations) {
      var res = ops.mutable.setIn(["meta", key], value, branch);
      return res;
    }

    return ops.batch.setIn(batchToken, ["meta", key], value, branch);
  };

  _proto.getMeta = function getMeta(branch, key) {
    return branch.meta[key];
  };

  _proto.query = function query(branch, clauses) {
    var _this2 = this;

    if (clauses.length === 0) {
      return this.accessList(branch);
    }

    var idAttribute = this.idAttribute;
    var optimallyOrderedClauses = sortBy(clauses, function (clause) {
      if (clauseFiltersByAttribute(clause, idAttribute)) {
        return 1;
      }

      if (clauseReducesResultSetSize(clause)) {
        return 2;
      }

      return 3;
    });

    var reducer = function reducer(rows, clause) {
      var type = clause.type,
          payload = clause.payload;

      if (!rows) {
        /**
         * First time this reducer is called during query.
         * This is where we apply query optimizations.
         */
        if (clauseFiltersByAttribute(clause, idAttribute)) {
          /**
           * Payload specified a primary key. Use PK index
           * to look up the single row identified by the PK.
           */
          var id = payload[idAttribute];
          var remainingPayload = Object.keys(payload).reduce(function (withoutPkAttr, filterAttr) {
            if (filterAttr !== idAttribute) {
              withoutPkAttr[filterAttr] = payload[filterAttr];
            }

            return withoutPkAttr;
          }, {});
          var ids = _this2.idExists(branch, id) ? [id] : [];

          if (Object.keys(remainingPayload).length) {
            /**
             * Payload has additional, non-PK columns.
             * Filter accessed row by remaining payload (if one was found).
             */
            return reducer(_this2.accessIds(branch, ids), _objectSpread(_objectSpread({}, clause), {}, {
              payload: remainingPayload
            }));
          }
          /**
           * No need to filter these rows any further.
           * The primary key value satisfies this clause's conditions.
           */


          return _this2.accessIds(branch, ids);
        }

        if (type === FILTER && _typeof(payload) === "object") {
          var indexes = Object.entries(branch.indexes);
          var accessedIndexes = [];
          var indexAttrs = [];
          indexes.forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                attr = _ref2[0],
                index = _ref2[1];

            if (clauseFiltersByAttribute(clause, attr)) {
              /**
               * Payload specified an indexed attribute. Use index
               * to potentially decrease amount of accessed rows.
               */
              if (index.hasOwnProperty(payload[attr])) {
                accessedIndexes.push(index[payload[attr]]);
                indexAttrs.push(attr);
              }
            }
          });
          /**
           * Calculate set of unique PK values corresponding to each
           * foreign key's attribute value. Then retrieve all those rows.
           */

          if (accessedIndexes.length) {
            var lastIndex = accessedIndexes.pop();
            var indexedIds = accessedIndexes.reduce(function (result, index) {
              var indexSet = new Set(index);
              return result.filter(Set.prototype.has, indexSet);
            }, lastIndex);

            var _remainingPayload = Object.keys(payload).reduce(function (withoutIndexAttrs, filterAttr) {
              if (!indexAttrs.includes(filterAttr)) {
                withoutIndexAttrs[filterAttr] = payload[filterAttr];
              }

              return withoutIndexAttrs;
            }, {});

            if (Object.keys(_remainingPayload).length) {
              /**
               * Payload has additional, non-indexed columns.
               * Filter indexed rows by remaining payload (if any were found).
               */
              return reducer(_this2.accessIds(branch, indexedIds), _objectSpread(_objectSpread({}, clause), {}, {
                payload: _remainingPayload
              }));
            }
            /**
             * No need to filter these rows any further.
             * The used indexes satisfy this clause's conditions.
             */


            return _this2.accessIds(branch, indexedIds);
          }
        } // Give up optimization: Retrieve all rows (full table scan).


        return reducer(_this2.accessList(branch), clause);
      }

      switch (type) {
        case FILTER:
          {
            return filter(rows, payload);
          }

        case EXCLUDE:
          {
            return reject(rows, payload);
          }

        case ORDER_BY:
          {
            var _payload = _slicedToArray(payload, 2),
                iteratees = _payload[0],
                orders = _payload[1];

            return orderBy(rows, iteratees, normalizeOrders(orders));
          }

        default:
          return rows;
      }
    };

    return optimallyOrderedClauses.reduce(reducer, undefined);
  }
  /**
   * Returns the data structure including a new object `entry`
   * @param  {Object} tx - transaction info
   * @param  {Object} branch - the data structure state
   * @param  {Object} entry - the object to insert
   * @return {Object} an object with two keys: `state` and `created`.
   *                  `state` is the new table state and `created` is the
   *                  row that was created.
   */
  ;

  _proto.insert = function insert(tx, branch, entry) {
    var _ops$batch$merge3;

    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;
    var hasId = entry.hasOwnProperty(this.idAttribute);
    var workingState = branch; // This will not affect string id's.

    var _idSequencer = idSequencer(this.getMaxId(branch), entry[this.idAttribute]),
        _idSequencer2 = _slicedToArray(_idSequencer, 2),
        newMaxId = _idSequencer2[0],
        id = _idSequencer2[1];

    workingState = this.setMaxId(tx, branch, newMaxId);
    var finalEntry = hasId ? entry : ops.batch.set(batchToken, this.idAttribute, id, entry);
    var indexesToAppendTo = Object.keys(workingState.indexes).filter(function (fkAttr) {
      return entry.hasOwnProperty(fkAttr) && entry[fkAttr] !== null;
    }).map(function (fkAttr) {
      return [fkAttr, entry[fkAttr]];
    });

    if (withMutations) {
      ops.mutable.push(id, workingState[this.arrName]);
      ops.mutable.set(id, finalEntry, workingState[this.mapName]); // add id to indexes

      indexesToAppendTo.forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            attr = _ref4[0],
            value = _ref4[1];

        var attrIndex = workingState.indexes[attr];

        if (attrIndex.hasOwnProperty(value)) {
          ops.mutable.push(id, attrIndex[value]);
        } else {
          ops.mutable.set(value, [id], attrIndex);
        }
      });
      return {
        state: workingState,
        created: finalEntry
      };
    }

    var nextIndexes = ops.batch.merge(batchToken, indexesToAppendTo.reduce(function (indexMap, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          attr = _ref6[0],
          value = _ref6[1];

      indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);
      return indexMap;
    }, _objectSpread({}, workingState.indexes)), workingState.indexes);
    var nextState = ops.batch.merge(batchToken, (_ops$batch$merge3 = {}, _defineProperty(_ops$batch$merge3, this.arrName, ops.batch.push(batchToken, id, workingState[this.arrName])), _defineProperty(_ops$batch$merge3, this.mapName, ops.batch.merge(batchToken, _defineProperty({}, id, finalEntry), workingState[this.mapName])), _defineProperty(_ops$batch$merge3, "indexes", nextIndexes), _ops$batch$merge3), workingState);
    return {
      state: nextState,
      created: finalEntry
    };
  }
  /**
   * Returns the data structure with objects where `rows`
   * are merged with `mergeObj`.
   *
   * @param  {Object} tx - transaction info
   * @param  {Object} branch - the data structure state
   * @param  {Object[]} rows - rows to update
   * @param  {Object} mergeObj - The object to merge with each row.
   * @return {Object}
   */
  ;

  _proto.update = function update(tx, branch, rows, mergeObj) {
    var _this3 = this,
        _ops$batch$merge6;

    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;

    var mergeObjInto = function mergeObjInto(row) {
      var merge = withMutations ? ops.mutable.merge : ops.batch.merge(batchToken);
      return merge(mergeObj, row);
    };

    var set = withMutations ? ops.mutable.set : ops.batch.set(batchToken);
    var indexedAttrs = Object.keys(branch.indexes).filter(function (attr) {
      return mergeObj.hasOwnProperty(attr);
    });
    var indexIdsToAdd = [];
    var indexIdsToDelete = [];
    var nextMap = rows.reduce(function (map, row) {
      var prevAttrValues = indexedAttrs.reduce(function (valueMap, attr) {
        return _objectSpread(_objectSpread({}, valueMap), {}, _defineProperty({}, attr, row[attr]));
      }, {});
      var result = mergeObjInto(row);
      var nextAttrValues = indexedAttrs.reduce(function (valueMap, attr) {
        return _objectSpread(_objectSpread({}, valueMap), {}, _defineProperty({}, attr, result[attr]));
      }, {});
      var id = result[_this3.idAttribute];
      var nextRow = set(id, result, map);
      indexedAttrs.forEach(function (attr) {
        var prevValue = prevAttrValues[attr];
        var nextValue = nextAttrValues[attr];

        if (prevValue === nextValue) {
          // attribute has not changed, no need to update any index
          return;
        }

        if (prevValue !== null && typeof prevValue !== "undefined") {
          // remove id from attribute's index for its old value
          indexIdsToDelete.push([attr, prevValue, id]);
        }

        if (nextValue !== null) {
          // add id to attribute's index for its new value
          indexIdsToAdd.push([attr, nextValue, id]);
        }
      });
      return nextRow;
    }, branch[this.mapName]);
    var nextIndexes = branch.indexes;

    if (withMutations) {
      indexIdsToDelete.forEach(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 3),
            attr = _ref8[0],
            value = _ref8[1],
            id = _ref8[2];

        var arr = nextIndexes[attr][value];
        var idx = arr.indexOf(id);
        ops.mutable.splice(idx, 1, [], arr);
      });
      indexIdsToAdd.forEach(function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 3),
            attr = _ref10[0],
            value = _ref10[1],
            id = _ref10[2];

        ops.mutable.push(id, nextIndexes[attr][value]);
      });
    } else {
      if (indexIdsToAdd.length) {
        nextIndexes = ops.batch.merge(batchToken, indexIdsToAdd.reduce(function (indexMap, _ref11) {
          var _ref12 = _slicedToArray(_ref11, 3),
              attr = _ref12[0],
              value = _ref12[1],
              id = _ref12[2];

          indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);
          return indexMap;
        }, _objectSpread({}, nextIndexes)), nextIndexes);
      }

      if (indexIdsToDelete.length) {
        nextIndexes = ops.batch.merge(batchToken, indexIdsToDelete.reduce(function (indexMap, _ref13) {
          var _ref14 = _slicedToArray(_ref13, 3),
              attr = _ref14[0],
              value = _ref14[1],
              id = _ref14[2];

          indexMap[attr] = ops.batch.merge(batchToken, _defineProperty({}, value, ops.batch.filter(batchToken, function (rowId) {
            return rowId !== id;
          }, indexMap[attr][value])), indexMap[attr]);
          return indexMap;
        }, _objectSpread({}, nextIndexes)), nextIndexes);
      }
    }

    return ops.batch.merge(batchToken, (_ops$batch$merge6 = {}, _defineProperty(_ops$batch$merge6, this.mapName, nextMap), _defineProperty(_ops$batch$merge6, "indexes", nextIndexes), _ops$batch$merge6), branch);
  }
  /**
   * Returns the data structure without rows `rows`.
   * @param  {Object} tx - transaction info
   * @param  {Object} branch - the data structure state
   * @param  {Object[]} rows - rows to update
   * @return {Object} the data structure without ids in `idsToDelete`.
   */
  ;

  _proto["delete"] = function _delete(tx, branch, rows) {
    var _this4 = this,
        _ops$batch$merge7;

    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;
    var arrName = this.arrName,
        mapName = this.mapName;
    var arr = branch[arrName];
    var idsToDelete = rows.map(function (row) {
      return row[_this4.idAttribute];
    });

    if (withMutations) {
      idsToDelete.forEach(function (id) {
        var idx = arr.indexOf(id);
        ops.mutable.splice(idx, 1, [], arr);
        ops.mutable.omit(id, branch[mapName]);
      }); // delete ids from all indexes

      Object.values(branch.indexes).forEach(function (attrIndex) {
        return Object.values(attrIndex).forEach(function (valueIndex) {
          return idsToDelete.forEach(function (id) {
            var idx = valueIndex.indexOf(id);

            if (idx !== -1) {
              ops.mutable.splice(idx, 1, [], valueIndex);
            }
          });
        });
      });
      return branch;
    }

    var nextIndexes = ops.batch.merge(batchToken, Object.entries(branch.indexes).reduce(function (indexMap, _ref15) {
      var _ref16 = _slicedToArray(_ref15, 2),
          attr = _ref16[0],
          attrIndex = _ref16[1];

      indexMap[attr] = ops.batch.merge(batchToken, Object.entries(attrIndex).reduce(function (attrIndexMap, _ref17) {
        var _ref18 = _slicedToArray(_ref17, 2),
            value = _ref18[0],
            valueIndex = _ref18[1];

        attrIndexMap[value] = ops.batch.filter(batchToken, function (id) {
          return !idsToDelete.includes(id);
        }, valueIndex);
        return attrIndexMap;
      }, _objectSpread({}, indexMap[attr])), indexMap[attr]);
      return indexMap;
    }, _objectSpread({}, branch.indexes)), branch.indexes);
    return ops.batch.merge(batchToken, (_ops$batch$merge7 = {}, _defineProperty(_ops$batch$merge7, arrName, ops.batch.filter(batchToken, function (id) {
      return !idsToDelete.includes(id);
    }, branch[arrName])), _defineProperty(_ops$batch$merge7, mapName, ops.batch.omit(batchToken, idsToDelete, branch[mapName])), _defineProperty(_ops$batch$merge7, "indexes", ops.batch.merge(batchToken, nextIndexes, branch.indexes)), _ops$batch$merge7), branch);
  };

  return Table;
}();
export default Table;