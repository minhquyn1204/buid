import _typeof from "@babel/runtime/helpers/typeof";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import ops from "immutable-ops";
import { FILTER, EXCLUDE } from "./constants";
/**
 * @module utils
 * @private
 */

/** @private */

function warnDeprecated(msg) {
  var logger = typeof console.warn === "function" ? console.warn.bind(console) : console.log.bind(console);
  return logger(msg);
}
/** @private */


function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
/**
 * Returns the branch name for a many-to-many relation.
 * The name is the combination of the model name and the field name the relation
 * was declared. The field name's first letter is capitalized.
 *
 * Example: model `Author` has a many-to-many relation to the model `Book`, defined
 * in the `Author` field `books`. The many-to-many branch name will be `AuthorBooks`.
 *
 * @param  {string} declarationModelName - the name of the model the many-to-many relation was declared on
 * @param  {string} fieldName            - the field name where the many-to-many relation was declared on
 * @return {string} The branch name for the many-to-many relation.
 */


function m2mName(declarationModelName, fieldName) {
  return declarationModelName + capitalize(fieldName);
}
/**
 * Returns the fieldname that saves a foreign key to the
 * model id where the many-to-many relation was declared.
 *
 * Example: `Author` => `fromAuthorId`
 *
 * @param  {string} declarationModelName - the name of the model where the relation was declared
 * @return {string} the field name in the through model for `declarationModelName`'s foreign key.
 */


function m2mFromFieldName(declarationModelName) {
  return "from".concat(declarationModelName, "Id");
}
/**
 * Returns the fieldname that saves a foreign key in a many-to-many through model to the
 * model where the many-to-many relation was declared.
 *
 * Example: `Book` => `toBookId`
 *
 * @param  {string} otherModelName - the name of the model that was the target of the many-to-many
 *                                   declaration.
 * @return {string} the field name in the through model for `otherModelName`'s foreign key..
 */


function m2mToFieldName(otherModelName) {
  return "to".concat(otherModelName, "Id");
}
/** */


function reverseFieldName(modelName) {
  return modelName.toLowerCase() + "Set"; // eslint-disable-line prefer-template
}
/** @private */


function querySetDelegatorFactory(methodName) {
  return function querySetDelegator() {
    var _this$getQuerySet;

    return (_this$getQuerySet = this.getQuerySet())[methodName].apply(_this$getQuerySet, arguments);
  };
}
/** @private */


function querySetGetterDelegatorFactory(getterName) {
  return function querySetGetterDelegator() {
    var qs = this.getQuerySet();
    return qs[getterName];
  };
}
/** @private */


function forEachSuperClass(subClass, func) {
  var currClass = subClass;

  while (currClass !== Function.prototype) {
    func(currClass);
    currClass = Object.getPrototypeOf(currClass);
  }
}
/** */


function attachQuerySetMethods(modelClass, querySetClass) {
  var leftToDefine = querySetClass.sharedMethods.slice(); // There is no way to get a property descriptor for the whole prototype chain;
  // only from an objects own properties. Therefore we traverse the whole prototype
  // chain for querySet.

  forEachSuperClass(querySetClass, function (cls) {
    for (var i = 0; i < leftToDefine.length; i++) {
      var defined = false;
      var methodName = leftToDefine[i];
      var descriptor = Object.getOwnPropertyDescriptor(cls.prototype, methodName);

      if (typeof descriptor !== "undefined") {
        if (typeof descriptor.get !== "undefined") {
          descriptor.get = querySetGetterDelegatorFactory(methodName);
          Object.defineProperty(modelClass, methodName, descriptor);
        } else {
          modelClass[methodName] = querySetDelegatorFactory(methodName);
        }

        defined = true;
      }

      if (defined) {
        leftToDefine.splice(i--, 1);
      }
    }
  });
}
/**
 * Normalizes `entity` to an id, where `entity` can be an id
 * or a Model instance.
 *
 * @param  {*} entity - either a Model instance or an id value
 * @return {*} the id value of `entity`
 */


function normalizeEntity(entity) {
  if (entity !== null && typeof entity !== "undefined" && typeof entity.getId === "function") {
    return entity.getId();
  }

  return entity;
}
/** */


function reverseFieldErrorMessage(modelName, fieldName, toModelName, backwardsFieldName) {
  return ["Reverse field ".concat(backwardsFieldName, " already defined"), " on model ".concat(toModelName, ". To fix, set a custom related"), " name on ".concat(modelName, ".").concat(fieldName, ".")].join("");
}
/**
 * Fastest way to check if two objects are equal.
 * Object and array values have to be referentially equal.
 */


function objectShallowEquals(a, b) {
  var entriesInA = Object.entries(Object(a));

  if (entriesInA.length !== Object.keys(b).length) {
    return false;
  }

  return entriesInA.every(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    return b.hasOwnProperty(key) && b[key] === value;
  });
}
/** */


function arrayDiffActions(sourceArr, targetArr) {
  var itemsInBoth = sourceArr.filter(function (item) {
    return targetArr.includes(item);
  });
  var deleteItems = sourceArr.filter(function (item) {
    return !itemsInBoth.includes(item);
  });
  var addItems = targetArr.filter(function (item) {
    return !itemsInBoth.includes(item);
  });

  if (deleteItems.length || addItems.length) {
    return {
      "delete": deleteItems,
      add: addItems
    };
  }

  return null;
}

var getBatchToken = ops.getBatchToken;
/**
 * @return boolean
 */

function clauseFiltersByAttribute(_ref3, attribute) {
  var type = _ref3.type,
      payload = _ref3.payload;
  if (type !== FILTER) return false;

  if (_typeof(payload) !== "object") {
    /**
     * payload could also be a function in which case
     * we would have no way of knowing what it does,
     * so we default to false for non-objects
     */
    return false;
  }

  if (!payload.hasOwnProperty(attribute)) return false;
  var attributeValue = payload[attribute];
  if (attributeValue === null) return false;
  if (attributeValue === undefined) return false;
  return true;
}
/**
 * @return boolean
 */


function clauseReducesResultSetSize(_ref4) {
  var type = _ref4.type;
  return [FILTER, EXCLUDE].includes(type);
}
/**
 * @param {Object} object
 * @return Object
 */


function mapValues(object, func) {
  return Object.entries(object).reduce(function (newObject, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        key = _ref6[0],
        value = _ref6[1];

    newObject[key] = func(value);
    return newObject;
  }, {});
}
/** */


function normalizeModelReference(modelNameOrClass) {
  if (!modelNameOrClass || typeof modelNameOrClass === "string") {
    return modelNameOrClass;
  }

  return modelNameOrClass.modelName;
}

export { attachQuerySetMethods, m2mName, m2mFromFieldName, m2mToFieldName, reverseFieldName, normalizeEntity, reverseFieldErrorMessage, objectShallowEquals, ops, arrayDiffActions, getBatchToken, clauseFiltersByAttribute, clauseReducesResultSetSize, warnDeprecated, mapValues, normalizeModelReference };