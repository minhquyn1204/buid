import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import Session from "./Session";
import QuerySet from "./QuerySet";
import { attr } from "./fields";
import ForeignKey from "./fields/ForeignKey";
import ManyToMany from "./fields/ManyToMany";
import OneToOne from "./fields/OneToOne";
import { CREATE, UPDATE, DELETE, FILTER } from "./constants";
import { normalizeEntity, arrayDiffActions, objectShallowEquals, warnDeprecated, m2mName } from "./utils";
/**
 * Generates a query specification to get the instance's
 * corresponding table row using its primary key.
 *
 * @private
 * @returns {Object}
 */

function getByIdQuery(modelInstance) {
  var modelClass = modelInstance.getClass();
  var idAttribute = modelClass.idAttribute,
      modelName = modelClass.modelName;
  return {
    table: modelName,
    clauses: [{
      type: FILTER,
      payload: _defineProperty({}, idAttribute, modelInstance.getId())
    }]
  };
}
/**
 * The heart of an ORM, the data model.
 *
 * The fields you specify to the Model will be used to generate
 * a schema to the database, related property accessors, and
 * possibly through models.
 *
 * In each {@link Session} you instantiate from an {@link ORM} instance,
 * you will receive a session-specific subclass of this Model. The methods
 * you define here will be available to you in sessions.
 *
 * An instance of {@link Model} represents a record in the database, though
 * it is possible to generate multiple instances from the same record in the database.
 *
 * To create data models in your schema, subclass {@link Model}. To define
 * information about the data model, override static class methods. Define instance
 * logic by defining prototype methods (without `static` keyword).
 */


var Model = /*#__PURE__*/function () {
  /**
   * Creates a Model instance from it's properties.
   * Don't use this to create a new record; Use the static method {@link Model#create}.
   * @param  {Object} props - the properties to instantiate with
   */
  function Model(props) {
    this._initFields(props);
  }

  var _proto = Model.prototype;

  _proto._initFields = function _initFields(props) {
    var _this = this;

    var propsObj = Object(props);
    this._fields = _objectSpread({}, propsObj);
    Object.keys(propsObj).forEach(function (fieldName) {
      // In this case, we got a prop that wasn't defined as a field.
      // Assuming it's an arbitrary data field, making an instance-specific
      // descriptor for it.
      // Using the in operator as the property could be defined anywhere
      // on the prototype chain.
      if (!(fieldName in _this)) {
        Object.defineProperty(_this, fieldName, {
          get: function get() {
            return _this._fields[fieldName];
          },
          set: function set(value) {
            return _this.set(fieldName, value);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
  };

  Model.toString = function toString() {
    return "ModelClass: ".concat(this.modelName);
  }
  /**
   * Returns the options object passed to the database for the table that represents
   * this Model class.
   *
   * Returns an empty object by default, which means the database
   * will use default options. You can either override this function to return the options
   * you want to use, or assign the options object as a static property of the same name to the
   * Model class.
   *
   * @return {Object} the options object passed to the database for the table
   *                  representing this Model class.
   */
  ;

  Model.options = function options() {
    return {};
  }
  /**
   * Manually mark individual instances as accessed.
   * This allows invalidating selector memoization within mutable sessions.
   *
   * @param {Array.<*>} ids - Array of primary key values
   * @return {undefined}
   */
  ;

  Model.markAccessed = function markAccessed(ids) {
    if (typeof this._session === "undefined") {
      throw new Error(["Tried to mark rows of the ".concat(this.modelName, " model as accessed without a session. "), "Create a session using `session = orm.session()` and call ", "`session[\"".concat(this.modelName, "\"].markAccessed` instead.")].join(""));
    }

    this.session.markAccessed(this.modelName, ids);
  }
  /**
   * Manually mark this model's table as scanned.
   * This allows invalidating selector memoization within mutable sessions.
   *
   * @return {undefined}
   */
  ;

  Model.markFullTableScanned = function markFullTableScanned() {
    if (typeof this._session === "undefined") {
      throw new Error(["Tried to mark the ".concat(this.modelName, " model as full table scanned without a session. "), "Create a session using `session = orm.session()` and call ", "`session[\"".concat(this.modelName, "\"].markFullTableScanned` instead.")].join(""));
    }

    this.session.markFullTableScanned(this.modelName);
  }
  /**
   * Manually mark indexes as accessed.
   * This allows invalidating selector memoization within mutable sessions.
   *
   * @param {Array.<Array.<*,*>>} indexes - Array of column-value pairs
   * @return {undefined}
   */
  ;

  Model.markAccessedIndexes = function markAccessedIndexes(indexes) {
    var _this2 = this;

    if (typeof this._session === "undefined") {
      throw new Error(["Tried to mark indexes for the ".concat(this.modelName, " model as accessed without a session. "), "Create a session using `session = orm.session()` and call ", "`session[\"".concat(this.modelName, "\"].markAccessedIndexes` instead.")].join(""));
    }

    this.session.markAccessedIndexes(indexes.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          attribute = _ref2[0],
          value = _ref2[1];

      return [_this2.modelName, attribute, value];
    }));
  }
  /**
   * Returns the id attribute of this {@link Model}.
   *
   * @return {string} The id attribute of this {@link Model}.
   */
  ;

  /**
   * Connect the model class to a {@link Session}.
   *
   * @private
   * @param  {Session} session - The session to connect to.
   */
  Model.connect = function connect(session) {
    if (!(session instanceof Session)) {
      throw new Error("A model can only be connected to instances of Session.");
    }

    this._session = session;
  }
  /**
   * Get the current {@link Session} instance.
   *
   * @private
   * @return {Session} The current {@link Session} instance.
   */
  ;

  /**
   * Returns an instance of the model's `querySetClass` field.
   * By default, this will be an empty {@link QuerySet}.
   *
   * @return {Object} An instance of the model's `querySetClass`.
   */
  Model.getQuerySet = function getQuerySet() {
    var QuerySetClass = this.querySetClass;
    return new QuerySetClass(this);
  }
  /**
   * @return {undefined}
   */
  ;

  Model.invalidateClassCache = function invalidateClassCache() {
    this.isSetUp = undefined;
    this.virtualFields = {};
  }
  /**
   * @see {@link Model.getQuerySet}
   */
  ;

  /**
   * Returns parameters to be passed to {@link Table} instance.
   *
   * @private
   */
  Model.tableOptions = function tableOptions() {
    if (typeof this.backend === "function") {
      warnDeprecated("`Model.backend` has been deprecated. Please rename to `.options`.");
      return this.backend();
    }

    if (this.backend) {
      warnDeprecated("`Model.backend` has been deprecated. Please rename to `.options`.");
      return this.backend;
    }

    if (typeof this.options === "function") {
      return this.options();
    }

    return this.options;
  }
  /**
   * Creates a new record in the database, instantiates a {@link Model} and returns it.
   *
   * If you pass values for many-to-many fields, instances are created on the through
   * model as well.
   *
   * @param  {Object} userProps - the new {@link Model}'s properties.
   * @return {Model} a new {@link Model} instance.
   */
  ;

  Model.create = function create(userProps) {
    var _this3 = this;

    if (typeof this._session === "undefined") {
      throw new Error(["Tried to create a ".concat(this.modelName, " model instance without a session. "), "Create a session using `session = orm.session()` and call ", "`session[\"".concat(this.modelName, "\"].create` instead.")].join(""));
    }

    var props = _objectSpread({}, userProps);

    var m2mRelations = {};
    var declaredFieldNames = Object.keys(this.fields);
    var declaredVirtualFieldNames = Object.keys(this.virtualFields);
    declaredFieldNames.forEach(function (key) {
      var field = _this3.fields[key];
      var valuePassed = userProps.hasOwnProperty(key);

      if (!(field instanceof ManyToMany)) {
        if (valuePassed) {
          var value = userProps[key];
          props[key] = normalizeEntity(value);
        } else if (field.getDefault) {
          props[key] = field.getDefault();
        }
      } else if (valuePassed) {
        // Save for later processing
        m2mRelations[key] = userProps[key];

        if (!field.as) {
          /**
           * The relationship does not have an accessor
           * Discard the value from props as the field will be populated later with instances
           * from the target models when refreshing the M2M relations.
           * If the relationship does have an accessor (`as`) field then we do want to keep this
           * original value in the props to expose the raw list of IDs from the instance.
           */
          delete props[key];
        }
      }
    }); // add backward many-many if required

    declaredVirtualFieldNames.forEach(function (key) {
      if (!m2mRelations.hasOwnProperty(key)) {
        var field = _this3.virtualFields[key];

        if (userProps.hasOwnProperty(key) && field instanceof ManyToMany) {
          // If a value is supplied for a ManyToMany field,
          // discard them from props and save for later processing.
          m2mRelations[key] = userProps[key];
          delete props[key];
        }
      }
    });
    var newEntry = this.session.applyUpdate({
      action: CREATE,
      table: this.modelName,
      payload: props
    });
    var ThisModel = this;
    var instance = new ThisModel(newEntry);

    instance._refreshMany2Many(m2mRelations); // eslint-disable-line no-underscore-dangle


    return instance;
  }
  /**
   * Creates a new or update existing record in the database, instantiates a {@link Model} and returns it.
   *
   * If you pass values for many-to-many fields, instances are created on the through
   * model as well.
   *
   * @param  {Object} userProps - the required {@link Model}'s properties.
   * @return {Model} a {@link Model} instance.
   */
  ;

  Model.upsert = function upsert(userProps) {
    if (typeof this.session === "undefined") {
      throw new Error(["Tried to upsert a ".concat(this.modelName, " model instance without a session. "), "Create a session using `session = orm.session()` and call ", "`session[\"".concat(this.modelName, "\"].upsert` instead.")].join(""));
    }

    var idAttribute = this.idAttribute;

    if (userProps.hasOwnProperty(idAttribute)) {
      var id = userProps[idAttribute];

      if (this.idExists(id)) {
        var model = this.withId(id);
        model.update(userProps);
        return model;
      }
    }

    return this.create(userProps);
  }
  /**
   * Returns a {@link Model} instance for the object with id `id`.
   * Returns `null` if the model has no instance with id `id`.
   *
   * You can use {@link Model#idExists} to check for existence instead.
   *
   * @param  {*} id - the `id` of the object to get
   * @throws If object with id `id` doesn't exist
   * @return {Model|null} {@link Model} instance with id `id`
   */
  ;

  Model.withId = function withId(id) {
    return this.get(_defineProperty({}, this.idAttribute, id));
  }
  /**
   * Returns a boolean indicating if an entity
   * with the id `id` exists in the state.
   *
   * @param  {*}  id - a value corresponding to the id attribute of the {@link Model} class.
   * @return {Boolean} a boolean indicating if entity with `id` exists in the state
   *
   * @since 0.11.0
   */
  ;

  Model.idExists = function idExists(id) {
    return this.exists(_defineProperty({}, this.idAttribute, id));
  }
  /**
   * Returns a boolean indicating if an entity
   * with the given props exists in the state.
   *
   * @param  {*}  props - a key-value that {@link Model} instances should have to be considered as existing.
   * @return {Boolean} a boolean indicating if entity with `props` exists in the state
   */
  ;

  Model.exists = function exists(lookupObj) {
    if (typeof this.session === "undefined") {
      throw new Error(["Tried to check if a ".concat(this.modelName, " model instance exists without a session. "), "Create a session using `session = orm.session()` and call ", "`session[\"".concat(this.modelName, "\"].exists` instead.")].join(""));
    }

    return Boolean(this._findDatabaseRows(lookupObj).length);
  }
  /**
   * Gets the {@link Model} instance that matches properties in `lookupObj`.
   * Throws an error if {@link Model} if multiple records match
   * the properties.
   *
   * @param  {Object} lookupObj - the properties used to match a single entity.
   * @throws {Error} If more than one entity matches the properties in `lookupObj`.
   * @return {Model} a {@link Model} instance that matches the properties in `lookupObj`.
   */
  ;

  Model.get = function get(lookupObj) {
    var ThisModel = this;

    var rows = this._findDatabaseRows(lookupObj);

    if (rows.length === 0) {
      return null;
    }

    if (rows.length > 1) {
      throw new Error("Expected to find a single row in `".concat(this.modelName, ".get`. Found ").concat(rows.length, "."));
    }

    return new ThisModel(rows[0]);
  }
  /**
   * Gets the {@link Model} class or subclass constructor (the class that
   * instantiated this instance).
   *
   * @return {Model} The {@link Model} class or subclass constructor used to instantiate
   *                 this instance.
   */
  ;

  _proto.getClass = function getClass() {
    return this.constructor;
  }
  /**
   * Gets the id value of the current instance by looking up the id attribute.
   * @return {*} The id value of the current instance.
   */
  ;

  _proto.getId = function getId() {
    return this._fields[this.getClass().idAttribute];
  }
  /**
   * Returns a reference to the plain JS object in the store.
   * It contains all the properties that you pass when creating the model,
   * except for primary keys of many-to-many relationships with a custom accessor.
   *
   * Make sure never to mutate this.
   *
   * @return {Object} a reference to the plain JS object in the store
   */
  ;

  /**
   * Finds all rows in this model's table that match the given `lookupObj`.
   * If no `lookupObj` is passed, all rows in the model's table will be returned.
   *
   * @param  {*}  props - a key-value that {@link Model} instances should have to be considered as existing.
   * @return {Boolean} a boolean indicating if entity with `props` exists in the state
   * @private
   */
  Model._findDatabaseRows = function _findDatabaseRows(lookupObj) {
    var querySpec = {
      table: this.modelName
    };

    if (lookupObj) {
      querySpec.clauses = [{
        type: FILTER,
        payload: lookupObj
      }];
    }

    return this.session.query(querySpec).rows;
  }
  /**
   * Returns a string representation of the {@link Model} instance.
   *
   * @return {string} A string representation of this {@link Model} instance.
   */
  ;

  _proto.toString = function toString() {
    var _this4 = this;

    var ThisModel = this.getClass();
    var className = ThisModel.modelName;
    var fieldNames = Object.keys(ThisModel.fields);
    var fields = fieldNames.map(function (fieldName) {
      var field = ThisModel.fields[fieldName];

      if (field instanceof ManyToMany) {
        var ids = _this4[fieldName].toModelArray().map(function (model) {
          return model.getId();
        });

        return "".concat(fieldName, ": [").concat(ids.join(", "), "]");
      }

      var val = _this4._fields[fieldName];
      return "".concat(fieldName, ": ").concat(val);
    }).join(", ");
    return "".concat(className, ": {").concat(fields, "}");
  }
  /**
   * Returns a boolean indicating if `otherModel` equals this {@link Model} instance.
   * Equality is determined by shallow comparing their attributes.
   *
   * This equality is used when you call {@link Model#update}.
   * You can prevent model updates by returning `true` here.
   * However, a model will always be updated if its relationships are changed.
   *
   * @param  {Model} otherModel - a {@link Model} instance to compare
   * @return {Boolean} a boolean indicating if the {@link Model} instance's are equal.
   */
  ;

  _proto.equals = function equals(otherModel) {
    // eslint-disable-next-line no-underscore-dangle
    return objectShallowEquals(this._fields, otherModel._fields);
  }
  /**
   * Updates a property name to given value for this {@link Model} instance.
   * The values are immediately committed to the database.
   *
   * @param {string} propertyName - name of the property to set
   * @param {*} value - value assigned to the property
   * @return {undefined}
   */
  ;

  _proto.set = function set(propertyName, value) {
    this.update(_defineProperty({}, propertyName, value));
  }
  /**
   * Assigns multiple fields and corresponding values to this {@link Model} instance.
   * The updates are immediately committed to the database.
   *
   * @param  {Object} userMergeObj - an object that will be merged with this instance.
   * @return {undefined}
   */
  ;

  _proto.update = function update(userMergeObj) {
    var ThisModel = this.getClass();

    if (typeof ThisModel.session === "undefined") {
      throw new Error(["Tried to update a ".concat(ThisModel.modelName, " model instance without a session. "), "You cannot call `.update` on an instance that you did not receive from the database."].join(""));
    }

    var mergeObj = _objectSpread({}, userMergeObj);

    var fields = ThisModel.fields,
        virtualFields = ThisModel.virtualFields;
    var m2mRelations = {}; // If an array of entities or id's is supplied for a
    // many-to-many related field, clear the old relations
    // and add the new ones.
    // eslint-disable-next-line guard-for-in, no-restricted-syntax

    for (var mergeKey in mergeObj) {
      var isRealField = fields.hasOwnProperty(mergeKey);

      if (isRealField) {
        var field = fields[mergeKey];

        if (field instanceof ForeignKey || field instanceof OneToOne) {
          // update one-one/fk relations
          mergeObj[mergeKey] = normalizeEntity(mergeObj[mergeKey]);
        } else if (field instanceof ManyToMany) {
          // field is forward relation
          m2mRelations[mergeKey] = mergeObj[mergeKey];

          if (!field.as) {
            /**
             * The relationship does not have an accessor
             * Discard the value from props as the field will be populated later with instances
             * from the target models when refreshing the M2M relations.
             * If the relationship does have an accessor (`as`) field then we do want to keep this
             * original value in the props to expose the raw list of IDs from the instance.
             */
            delete mergeObj[mergeKey];
          }
        }
      } else if (virtualFields.hasOwnProperty(mergeKey)) {
        var _field = virtualFields[mergeKey];

        if (_field instanceof ManyToMany) {
          // field is backward relation
          m2mRelations[mergeKey] = mergeObj[mergeKey];
          delete mergeObj[mergeKey];
        }
      }
    }

    var mergedFields = _objectSpread(_objectSpread({}, this._fields), mergeObj);

    var updatedModel = new ThisModel(mergedFields); // only update fields if they have changed (referentially)

    if (!this.equals(updatedModel)) {
      this._initFields(mergedFields);

      ThisModel.session.applyUpdate({
        action: UPDATE,
        query: getByIdQuery(this),
        payload: mergeObj
      });
    } // update virtual fields


    this._refreshMany2Many(m2mRelations);
  }
  /**
   * Updates {@link Model} instance attributes to reflect the
   * database state in the current session.
   * @return {undefined}
   */
  ;

  _proto.refreshFromState = function refreshFromState() {
    this._initFields(this.ref);
  }
  /**
   * Deletes the record for this {@link Model} instance.
   * You'll still be able to access fields and values on the instance.
   *
   * @return {undefined}
   */
  ;

  _proto["delete"] = function _delete() {
    var ThisModel = this.getClass();

    if (typeof ThisModel.session === "undefined") {
      throw new Error(["Tried to delete a ".concat(ThisModel.modelName, " model instance without a session. "), "You cannot call `.delete` on an instance that you did not receive from the database."].join(""));
    }

    this._onDelete();

    ThisModel.session.applyUpdate({
      action: DELETE,
      query: getByIdQuery(this)
    });
  }
  /**
   * Update many-many relations for model.
   * @param relations
   * @return undefined
   * @private
   */
  ;

  _proto._refreshMany2Many = function _refreshMany2Many(relations) {
    var _this5 = this;

    var ThisModel = this.getClass();
    var fields = ThisModel.fields,
        virtualFields = ThisModel.virtualFields,
        modelName = ThisModel.modelName;
    Object.keys(relations).forEach(function (name) {
      var reverse = !fields.hasOwnProperty(name);
      var field = virtualFields[name];
      var values = relations[name];

      if (!Array.isArray(values)) {
        throw new TypeError("Failed to resolve many-to-many relationship: ".concat(modelName, "[").concat(name, "] must be an array (passed: ").concat(values, ")"));
      }

      var normalizedNewIds = values.map(normalizeEntity);

      var uniqueIds = _toConsumableArray(new Set(normalizedNewIds));

      if (normalizedNewIds.length !== uniqueIds.length) {
        throw new Error("Found duplicate id(s) when passing \"".concat(normalizedNewIds, "\" to ").concat(ThisModel.modelName, ".").concat(name, " value"));
      }

      var throughModelName = field.through || m2mName(ThisModel.modelName, name);
      var ThroughModel = ThisModel.session[throughModelName];
      var fromField;
      var toField;

      if (!reverse) {
        var _field$throughFields = field.throughFields;
        fromField = _field$throughFields.from;
        toField = _field$throughFields.to;
      } else {
        var _field$throughFields2 = field.throughFields;
        toField = _field$throughFields2.from;
        fromField = _field$throughFields2.to;
      }

      var currentIds = ThroughModel.filter(function (through) {
        return through[fromField] === _this5[ThisModel.idAttribute];
      }).toRefArray().map(function (ref) {
        return ref[toField];
      });
      var diffActions = arrayDiffActions(currentIds, normalizedNewIds);

      if (diffActions) {
        var idsToDelete = diffActions["delete"],
            idsToAdd = diffActions.add;

        if (idsToDelete.length > 0) {
          var _this6;

          (_this6 = _this5[field.as || name]).remove.apply(_this6, _toConsumableArray(idsToDelete));
        }

        if (idsToAdd.length > 0) {
          var _this7;

          (_this7 = _this5[field.as || name]).add.apply(_this7, _toConsumableArray(idsToAdd));
        }
      }
    });
  }
  /**
   * @return {undefined}
   * @private
   */
  ;

  _proto._onDelete = function _onDelete() {
    var _this$getClass = this.getClass(),
        virtualFields = _this$getClass.virtualFields; // eslint-disable-next-line guard-for-in, no-restricted-syntax


    for (var key in virtualFields) {
      var field = virtualFields[key];

      if (field instanceof ManyToMany) {
        // Delete any many-to-many rows the entity is included in.
        var descriptorKey = field.as || key;
        this[descriptorKey].clear();
      } else if (field instanceof ForeignKey) {
        var relatedQs = this[key];

        if (relatedQs.exists()) {
          relatedQs.update(_defineProperty({}, field.relatedName, null));
        }
      } else if (field instanceof OneToOne) {
        // Set null to any foreign keys or one to ones pointed to
        // this instance.
        if (this[key] !== null) {
          this[key][field.relatedName] = null;
        }
      }
    }
  } // DEPRECATED AND REMOVED METHODS

  /**
   * Returns a boolean indicating if an entity
   * with the id `id` exists in the state.
   *
   * @param  {*}  id - a value corresponding to the id attribute of the {@link Model} class.
   * @return {Boolean} a boolean indicating if entity with `id` exists in the state
   * @deprecated Please use {@link Model.idExists} instead.
   */
  ;

  Model.hasId = function hasId(id) {
    console.warn("`Model.hasId` has been deprecated. Please use `Model.idExists` instead.");
    return this.idExists(id);
  }
  /**
   * @deprecated See the 0.9 migration guide on the GitHub repo.
   * @throws {Error} Due to deprecation.
   */
  ;

  _proto.getNextState = function getNextState() {
    throw new Error("`Model.prototype.getNextState` has been removed. See the 0.9 " + "migration guide on the GitHub repo.");
  };

  _createClass(Model, [{
    key: "ref",
    get: function get() {
      var ThisModel = this.getClass(); // eslint-disable-next-line no-underscore-dangle

      return ThisModel._findDatabaseRows(_defineProperty({}, ThisModel.idAttribute, this.getId()))[0];
    }
  }], [{
    key: "idAttribute",
    get: function get() {
      if (typeof this._session === "undefined") {
        throw new Error(["Tried to get the ".concat(this.modelName, " model's id attribute without a session. "), "Create a session using `session = orm.session()` and access ", "`session[\"".concat(this.modelName, "\"].idAttribute` instead.")].join(""));
      }

      return this.session.db.describe(this.modelName).idAttribute;
    }
  }, {
    key: "session",
    get: function get() {
      return this._session;
    }
  }, {
    key: "query",
    get: function get() {
      return this.getQuerySet();
    }
  }]);

  return Model;
}();

Model.fields = {
  id: attr()
};
Model.virtualFields = {};
Model.querySetClass = QuerySet;
export default Model;