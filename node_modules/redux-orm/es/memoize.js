import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _typeof from "@babel/runtime/helpers/typeof";
import { STATE_FLAG } from "./constants";

var defaultEqualityCheck = function defaultEqualityCheck(a, b) {
  return a === b;
};

export var eqCheck = defaultEqualityCheck;

var isOrmState = function isOrmState(arg) {
  return arg && _typeof(arg) === "object" && arg.hasOwnProperty(STATE_FLAG);
};

var argsAreEqual = function argsAreEqual(lastArgs, nextArgs, equalityCheck) {
  return nextArgs.every(function (arg, index) {
    return isOrmState(arg) && isOrmState(lastArgs[index]) || equalityCheck(arg, lastArgs[index]);
  });
};

var rowsAreEqual = function rowsAreEqual(ids, rowsA, rowsB) {
  return ids.every(function (id) {
    return rowsA[id] === rowsB[id];
  });
};

var accessedModelInstancesAreEqual = function accessedModelInstancesAreEqual(previous, ormState, orm) {
  var accessedInstances = previous.accessedInstances;
  return Object.entries(accessedInstances).every(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        modelName = _ref2[0],
        instances = _ref2[1];

    // if the entire table has not been changed, we have nothing to do
    if (previous.ormState[modelName] === ormState[modelName]) {
      return true;
    }

    var _orm$getDatabase$desc = orm.getDatabase().describe(modelName),
        mapName = _orm$getDatabase$desc.mapName;

    var previousRows = previous.ormState[modelName][mapName];
    var rows = ormState[modelName][mapName];
    var accessedIds = Object.keys(instances);
    return rowsAreEqual(accessedIds, previousRows, rows);
  });
};

var accessedIndexesAreEqual = function accessedIndexesAreEqual(previous, ormState) {
  var accessedIndexes = previous.accessedIndexes;
  return Object.entries(accessedIndexes).every(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        modelName = _ref4[0],
        indexes = _ref4[1];

    return Object.entries(indexes).every(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          column = _ref6[0],
          values = _ref6[1];

      return values.every(function (value) {
        return previous.ormState[modelName].indexes[column][value] === ormState[modelName].indexes[column][value];
      });
    });
  });
};

var fullTableScannedModelsAreEqual = function fullTableScannedModelsAreEqual(previous, ormState) {
  return previous.fullTableScannedModels.every(function (modelName) {
    return previous.ormState[modelName] === ormState[modelName];
  });
};
/**
 * A memoizer to use with redux-orm
 * selectors. When the memoized function is first run,
 * the memoizer will remember the models that are accessed
 * during that function run.
 *
 * On subsequent runs, the memoizer will check if those
 * models' states have changed compared to the previous run.
 *
 * Memoization algorithm operates like this:
 *
 * 1. Has the selector been run before? If not, go to 6.
 *
 * 2. If the selector has other input selectors in addition to the
 *    ORM state selector, check their results for equality with the previous results.
 *    If they aren't equal, go to 6.
 *
 * 3. Some filter queries may have required scanning entire tables during the last run.
 *    If any of those tables have changed, go to 6.
 *
 * 4. Check which foreign key indexes the database has used to speed up queries
 *    during the last run. If any have changed, go to 6.
 *
 * 5. Check which Model's instances the selector has accessed during the last run.
 *    Check for equality with each of those states versus their states in the
 *    previous ORM state. If all of them are equal, return the previous result.
 *
 * 6. Run the selector. Check the Session object used by the selector for
 *    which Model's states were accessed, and merge them with the previously
 *    saved information about accessed models (if-else branching can change
 *    which models are accessed on different inputs). Save the ORM state and
 *    other arguments the selector was called with, overriding previously
 *    saved values. Save the selector result. Return the selector result.
 *
 * @private
 * @param  {Function} func - function to memoize
 * @param  {Function} argEqualityCheck - equality check function to use with normal
 *                                       selector args
 * @param  {ORM} orm - a redux-orm ORM instance
 * @return {Function} `func` memoized.
 */


export function memoize(func) {
  var argEqualityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;
  var orm = arguments.length > 2 ? arguments[2] : undefined;
  var previous = {
    /* Result of the previous function call */
    result: null,

    /* Arguments to the previous function call (excluding ORM state) */
    args: null,

    /**
     * Snapshot of the previous database.
     *
     * Lets us know how the tables looked like
     * during the previous function call.
     */
    ormState: null,

    /**
     * Names of models whose tables have been scanned completely
     * during previous function call (contains only model names)
     * Format example: ['Book']
     */
    fullTableScannedModels: [],

    /**
     * Map of which model instances have been accessed
     * during previous function call.
     * Contains only PKs of accessed instances.
     * Format example: { Book: { 1: true, 3: true } }
     */
    accessedInstances: {},

    /**
     * Map of which attribute indexes have been accessed
     * during previous function call.
     * Contains only attributes that were actually filtered on.
     * Author.withId(3).books would add 3 to the authorId index below.
     * Format example: { Book: { authorId: [1, 2], publisherId: [5] } }
     */
    accessedIndexes: {}
  };
  return function () {
    for (var _len = arguments.length, stateAndArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      stateAndArgs[_key] = arguments[_key];
    }

    /**
     * The first argument to this function needs to be
     * the ORM's reducer state in the user's Redux store.
     */
    var ormState = stateAndArgs[0],
        args = stateAndArgs.slice(1);
    var selectorWasCalledBefore = Boolean(previous.args);

    if (selectorWasCalledBefore && argsAreEqual(previous.args, args, argEqualityCheck) && fullTableScannedModelsAreEqual(previous, ormState) && accessedIndexesAreEqual(previous, ormState) && accessedModelInstancesAreEqual(previous, ormState, orm)) {
      /**
       * None of this selector's dependencies have changed
       * since the last time that we called it.
       */
      return previous.result;
    }
    /**
     * Start a session so that the selector can access the database.
     * Make this session immutable. This way we can find out if
     * the operations that the selector performs are cacheable.
     */


    var session = orm.session(ormState);
    /* Replace all ORM state arguments by the session above */

    var argsWithSession = args.map(function (arg) {
      return isOrmState(arg) ? session : arg;
    });
    /* This is where we call the actual function */

    var result = func.apply(null, argsWithSession); // eslint-disable-line prefer-spread

    /**
     * The metadata for the previous call are no longer valid.
     * Update cached values.
     */

    previous = {
      /* Arguments that were passed to the selector */
      args: args,

      /* Selector result */
      result: result,

      /* Redux state slice for session.state */
      ormState: ormState,

      /* Rows retrieved by resolved primary key */
      accessedInstances: session.accessedModelInstances,

      /* Foreign key indexes that were used to speed up queries */
      accessedIndexes: session.accessedIndexes,

      /* Tables that had to be scanned completely */
      fullTableScannedModels: session.fullTableScannedModels
    };
    return result;
  };
}