"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _immutableOps = require("immutable-ops");

var _constants = require("./constants");

var _utils = require("./utils");

var Session = /*#__PURE__*/function () {
  /**
   * Creates a new Session.
   *
   * @param  {Database} db - a {@link Database} instance
   * @param  {Object} state - the database state
   * @param  {Boolean} [withMutations] - whether the session should mutate data
   * @param  {Object} [batchToken] - used by the backend to identify objects that can be
   *                                 mutated.
   */
  function Session(schema, db, state, withMutations, batchToken) {
    var _this = this;

    this.schema = schema;
    this.db = db;
    this.state = state || db.getEmptyState();
    this.initialState = this.state;
    this.withMutations = Boolean(withMutations);
    this.batchToken = batchToken || (0, _immutableOps.getBatchToken)();
    this.modelData = {};
    this.models = schema.getModelClasses();
    this.sessionBoundModels = this.models.map(function (modelClass) {
      function SessionBoundModel() {
        return Reflect.construct(modelClass, arguments, SessionBoundModel); // eslint-disable-line prefer-rest-params
      }

      Reflect.setPrototypeOf(SessionBoundModel.prototype, modelClass.prototype);
      Reflect.setPrototypeOf(SessionBoundModel, modelClass);
      Object.defineProperty(_this, modelClass.modelName, {
        get: function get() {
          return SessionBoundModel;
        }
      });
      SessionBoundModel.connect(_this);
      return SessionBoundModel;
    });
  }

  var _proto = Session.prototype;

  _proto.getDataForModel = function getDataForModel(modelName) {
    if (!this.modelData[modelName]) {
      this.modelData[modelName] = {};
    }

    return this.modelData[modelName];
  };

  _proto.getModelData = function getModelData() {
    return this.modelData;
  };

  _proto.markAccessed = function markAccessed(modelName, modelIds) {
    var data = this.getDataForModel(modelName);

    if (!data.accessedInstances) {
      data.accessedInstances = {};
    }

    modelIds.forEach(function (id) {
      data.accessedInstances[id] = true;
    });
  };

  _proto.markFullTableScanned = function markFullTableScanned(modelName) {
    var data = this.getDataForModel(modelName);
    data.fullTableScanned = true;
  };

  _proto.markAccessedIndexes = function markAccessedIndexes(indexes) {
    var _this2 = this;

    indexes.forEach(function (_ref) {
      var _ref2 = (0, _slicedToArray2["default"])(_ref, 3),
          table = _ref2[0],
          attr = _ref2[1],
          value = _ref2[2];

      var data = _this2.getDataForModel(table);

      if (!data.accessedIndexes) {
        data.accessedIndexes = {};
      }

      data.accessedIndexes[attr] = [].concat((0, _toConsumableArray2["default"])(data.accessedIndexes[attr] || []), [value]);
    });
  };

  /**
   * Applies update to a model state.
   *
   * @private
   * @param {Object} update - the update object. Must have keys
   *                          `type`, `payload`.
   */
  _proto.applyUpdate = function applyUpdate(updateSpec) {
    var tx = this._getTransaction(updateSpec);

    var result = this.db.update(updateSpec, tx, this.state);
    var status = result.status,
        state = result.state,
        payload = result.payload;

    if (status !== _constants.SUCCESS) {
      throw new Error("Applying update failed with status ".concat(status, ". Payload: ").concat(payload));
    }

    this.state = state;
    return payload;
  };

  _proto.query = function query(querySpec) {
    var result = this.db.query(querySpec, this.state);

    this._markAccessedByQuery(querySpec, result);

    return result;
  };

  _proto._getTransaction = function _getTransaction(updateSpec) {
    var withMutations = this.withMutations;
    var action = updateSpec.action;
    var batchToken = this.batchToken;

    if ([_constants.UPDATE, _constants.DELETE].includes(action)) {
      batchToken = (0, _immutableOps.getBatchToken)();
    }

    return {
      batchToken: batchToken,
      withMutations: withMutations
    };
  };

  _proto._markAccessedByQuery = function _markAccessedByQuery(querySpec, result) {
    var table = querySpec.table,
        clauses = querySpec.clauses;
    var rows = result.rows;
    var idAttribute = this[table].idAttribute;
    var accessedIds = new Set(rows.map(function (row) {
      return row[idAttribute];
    }));
    var anyClauseFilteredByPk = clauses.some(function (clause) {
      if (!(0, _utils.clauseFiltersByAttribute)(clause, idAttribute)) {
        return false;
      }
      /**
       * We previously knew which row we wanted to access,
       * so there was no need to scan the entire table.
       */


      accessedIds.add(clause.payload[idAttribute]);
      return true;
    });
    var accessedIndexes = [];
    var indexes = this.state[table].indexes;
    clauses.forEach(function (clause) {
      Object.keys(indexes).forEach(function (attr) {
        if (!(0, _utils.clauseFiltersByAttribute)(clause, attr)) {
          return;
        }

        var value = clause.payload[attr];
        accessedIndexes.push([table, attr, value]);
      });
    });

    if (anyClauseFilteredByPk) {
      /**
       * The clauses have been ordered so that an indexed one was
       * the first to have been evaluated, and thus only the row
       * with the specified PK value has actually been accessed.
       */
      this.markAccessed(table, accessedIds);
    } else if (accessedIndexes.length) {
      /**
       * At least one clause was optimized using indexes.
       */
      this.markAccessed(table, accessedIds);
      this.markAccessedIndexes(accessedIndexes);
    } else {
      /**
       * At least one clause could not be efficiently optimized
       * or no clause was specified at all.
       */
      this.markFullTableScanned(table);
    }
  } // DEPRECATED AND REMOVED METHODS

  /**
   * @deprecated Access {@link Session#state} instead.
   */
  ;

  _proto.getNextState = function getNextState() {
    (0, _utils.warnDeprecated)("`Session.prototype.getNextState` has been deprecated. Access " + "the `Session.prototype.state` property instead.");
    return this.state;
  }
  /**
   * @deprecated
   * The Redux integration API is now decoupled from ORM and Session.<br>
   * See the 0.9 migration guide in the GitHub repo.
   */
  ;

  _proto.reduce = function reduce() {
    throw new Error("`Session.prototype.reduce` has been removed. The Redux integration API " + "is now decoupled from ORM and Session - see the 0.9 migration guide " + "in the GitHub repo.");
  };

  (0, _createClass2["default"])(Session, [{
    key: "accessedModelInstances",
    get: function get() {
      return Object.entries(this.getModelData()).reduce(function (result, _ref3) {
        var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        if (value.accessedInstances) {
          result[key] = value.accessedInstances;
        }

        return result;
      }, {});
    }
  }, {
    key: "fullTableScannedModels",
    get: function get() {
      return Object.entries(this.getModelData()).reduce(function (result, _ref5) {
        var _ref6 = (0, _slicedToArray2["default"])(_ref5, 2),
            key = _ref6[0],
            value = _ref6[1];

        if (value.fullTableScanned) {
          result.push(key);
        }

        return result;
      }, []);
    }
  }, {
    key: "accessedIndexes",
    get: function get() {
      return Object.entries(this.getModelData()).reduce(function (result, _ref7) {
        var _ref8 = (0, _slicedToArray2["default"])(_ref7, 2),
            key = _ref8[0],
            value = _ref8[1];

        if (value.accessedIndexes) {
          result[key] = value.accessedIndexes;
        }

        return result;
      }, {});
    }
  }]);
  return Session;
}();

var _default = Session;
exports["default"] = _default;